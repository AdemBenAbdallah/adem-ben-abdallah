---
title: Handling Asynchronous Data Fetching in React Beyond the Basics
description: Handling asynchronous data fetching in React
date: 2024-08-08
tags: ["react js", "react-query"]
published: true
---

If you've ever fetched data in a React app, you've likely encountered a basic pattern like this:

```js
const [id, setId] = useState(1);

useEffect(() => {
  fetch(`https://pokeapi.co/api/v2/pokemon/${id}`)
    .then((response) => response.json())
    .then((data) => setPokemon(data))
    .catch((error) => setError(error));
}, [id]);
```

This code fetches data from the PokemonAPI and displays it.
While it's great for tutorials, you definitely wouldn’t want to use it in production unless you enjoy debugging at 3 AM.
Let’s dive into some common pitfalls and how to avoid them.

## **1. Handling Loading and Error States**

The initial example doesn’t handle loading and error states,
leading to two major UX issues: cumulative layout shift and an infinite spinner.
To address this, you should manage these states explicitly:

```js /floatingStyles/
const [id, setId] = useState(1);
const [pokemon, setPokemon] = useState(null);
const [loading, setLoading] = useState(false);
const [error, setError] = useState(null);

useEffect(() => {
  setLoading(true);
  fetch(`https://pokeapi.co/api/v2/pokemon/${id}`)
    .then((response) => response.json())
    .then((data) => {
      setPokemon(data);
      setLoading(false);
    })
    .catch((error) => {
      setError(error);
      setLoading(false);
    });
}, [id]);
```

This approach ensures you can display appropriate feedback to the user while data is being fetched.

## **2. Avoiding Race Conditions**

A more subtle issue arises with multiple asynchronous requests.
Let's take an example where you have Pokémon data to display.
You have a button that, when clicked, changes the ID of the Pokemon

<figure>
  <Image src="/blog/race_cond1.png" alt="race condition 1" />
  <figcaption>
    Here, the `id` state is set to 1 when you click the button.
  </figcaption>
</figure>
You still haven't received the data from the first request, but you click the button
again, changing the `id` to 2.

<figure>
  <Image src="/blog/race_cond2.png" alt="race condition 2" />
  <figcaption>
    Here, the `id` state is set to 2 when you click the button.
  </figcaption>
</figure>
Your state with the pokemonId will be out of sync with the fetch call if the fetch
for ID 1 returns after the fetch for ID 2 due to happenstance.

<figure>
  <Image src="/blog/race_cond3.png" alt="race condition 3" />
  <figcaption>The data for `id` 2 returns first.</figcaption>
</figure>
<figure>
  <Image src="/blog/race_cond4.png" alt="race condition 4" />
  <figcaption>The data for `id` 1 returns second.</figcaption>
</figure>
This race condition can cause the UI to display incorrect data, as the state
might not reflect the latest requested `id`.

If the user clicks a button or triggers a change that results in a new fetch,
you could end up with race conditions this is how you can fix that:

```js /floatingStyles/
useEffect(() => {
  let isMounted = true;

  setLoading(true);
  fetch(`https://pokeapi.co/api/v2/pokemon/${id}`)
    .then((response) => response.json())
    .then((data) => {
      if (isMounted) {
        setPokemon(data);
      }
      setLoading(false);
    })
    .catch((error) => {
      if (isMounted) {
        setError(error);
      }
      setLoading(false);
    });

  return () => {
    isMounted = false;
  };
}, [id]);
```

By using a isMounted flag, you can ignore responses from outdated requests.

## **3. Abstracting Data Fetching Logic**

If you try to push that code to production, someone will definitely ask, 'Can you just hook it up as a custom hook?' 🪝
and you'll finish with code like this:

```js showLineNumbers {2-4}
const usePokemon = (id) => {
  const [id, setId] = useState(1);
  const [pokemon, setPokemon] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    let isMounted = true;

    setLoading(true);
    fetch(`https://pokeapi.co/api/v2/pokemon/${id}`)
      .then((response) => response.json())
      .then((data) => {
        if (isMounted) {
          setPokemon(data);
        }
        setLoading(false);
      })
      .catch((error) => {
        if (isMounted) {
          setError(error);
        }
        setLoading(false);
      });

    return () => {
      isMounted = false;
    };
  }, [id]);

  return { pokemon, loading, error };
};
```

This hook encapsulates the data fetching logic, making it reusable across different components.

## **4. Managing Data Duplication and State**

Okay, after addressing all the previous issues,
you might realize that another component also needs access to the same endpoint data.
It wouldn't make sense to send another request to the backend just to get the same results.
Remember, one of your key responsibilities as a software developer is to
reduce unnecessary costs and inefficiencies in your code.

When multiple components fetch the same data, it not only creates redundant requests but can also lead to inconsistencies.
To prevent this, you should create a context to share the data across multiple components. Alternatively,
you could lift the state up to a common parent component or use context to efficiently manage and distribute the data.

```js showLineNumber
import * as React from "react";

const queryContext = React.createContext([{}, () => {}]);

export function QueryProvider({ children }) {
  const tuple = React.useState({});

  return (
    <queryContext.Provider value={tuple}>{children}</queryContext.Provider>
  );
}

export default function useQuery(url) {
  const [state, setState] = React.useContext(queryContext);

  React.useEffect(() => {
    const update = (newState) =>
      setState((prevState) => ({
        ...prevState,
        [url]: { ...prevState[url], ...newState },
      }));
    let ignore = false;

    const handleFetch = async () => {
      update({ data: null, isLoading: true, error: null });

      try {
        const response = await fetch(url);

        if (ignore) {
          return;
        }
        if (res.ok === false) {
          throw new Error("Network response was not ok");
        }

        const data = await response.json();

        update({ data, isLoading: false, error: null });
      } catch (error) {
        update({ data: null, isLoading: false, error });
      }
    };
  }, [url]);

  return state[url] || { data: null, isLoading: true, error: null };
}
```

Are you still considering handling asynchronous data by yourself?
I don't think so. Before trying to solve a problem by myself,
I always check if others have already solved it for us,
and in most cases, they have. That's where React Query comes in.

## **5. Leveraging React Query**

To simplify data fetching and state management, consider using React Query. It efficiently handles caching,
synchronization, and state updates. Look at how easy it is to fetch data without worrying about all the previous issues.

```js showLineNumbers {10}
import { useQuery } from "@tanstack/react-query";

const fetchPokemon = async (id) => {
  const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${id}`);
  if (!res.ok) throw new Error("Network response was not ok");
  return res.json();
};

const Pokemon = () => {
  const [id, setId] = useState(1);

  const { data, isLoading, error } = useQuery({
    queryKey: ["pokemon", id],
    queryFn: () => fetchPokemon(id),
  });

  if (isLoading) return "Loading...";
  if (error) return "An error has occurred: " + error.message;

  return <div>....</div>;
};

export default Pokemon;
```

React Query abstracts away much of the complexity involved in handling asynchronous data and state, allowing you to focus on building features.

## **Conclusion**

Managing asynchronous data fetching in React involves more than just calling an API.
Handling loading and error states, avoiding race conditions, abstracting logic, managing data duplication,
and leveraging tools like React Query are essential for building robust and efficient applications.
By addressing these aspects, you’ll enhance both the reliability and user experience of your React apps.
